{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 1)  The built in android step detector worked pretty okay. It seemed to work best for portrait oriented phones than landscape. And better in the pocket than in your hand.\
\
2)We chose to do the smoothing filter. We did it as it made more sense to us, was a little bit more intuitive to implement than the low pass filter. We picked a step rate of .3 seconds as we buffered 30 samples, as we found half a second to be a little too much. This might just have to do with our own walking, and how we walk.\
\
3) We buffer 30 samples, once the buffer is filled we start finding the dynamic threshold, and then as new entries come in we apply this dynamic threshold to these newer events to see if they meet our requirements. Then we measure wether or not anything passes the dynamic threshold in one direction, for us this was on a negative slope.\
\
4) It\'92s kinda meh for anything other than portrait oriented phones. This might due to the different axis other than zed being increased.\
\
5) With python we had a lot of trouble, we found our same implementation was giving us different results for some odd reason, that it wasn\'92t totally in sync (by sync i mean in counting) with our local step detection algorithm.}